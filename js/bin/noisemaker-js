#!/usr/bin/env node

import jpeg from 'jpeg-js';
import { PNG} from 'pngjs';
import path from 'node:path';
import { mkdir, readFile, writeFile } from 'node:fs/promises';
import { createWriteStream } from 'node:fs';

import { Preset } from '../noisemaker/composer.js';
import { PRESETS } from '../noisemaker/presets.js';
import { Context } from '../noisemaker/context.js';
import { setSeed as setUtilSeed } from '../noisemaker/util.js';
import { setSeed as setValueSeed } from '../noisemaker/value.js';
import { random } from '../noisemaker/rng.js';
import { squareCropAndResize } from '../noisemaker/effects.js';
import { Tensor } from '../noisemaker/tensor.js';

const MAX_SEED_VALUE = 2 ** 32 - 1;

// Version string - keep in sync with pyproject.toml
const VERSION = '0.5.1';

const MAIN_HELP = `Usage: noisemaker-js [OPTIONS] COMMAND [ARGS]...

      Noisemaker - Let's make generative art with noise

  https://github.com/aayars/noisemaker

Options:
  -h, --help     Show this message and exit.
  --version      Show the version and exit.

Commands:
  generate     Generate a .png or .jpg from preset
  apply        Apply an effect to a .png or .jpg image
`;

const GENERATE_HELP = `Usage: noisemaker-js generate [OPTIONS] PRESET_NAME

  Generate a .png or .jpg from preset

Options:
  --width INTEGER         Output width, in pixels  [default: 1024]
  --height INTEGER        Output height, in pixels  [default: 1024]
  --time FLOAT            Time value for Z axis (simplex only)
  --speed FLOAT           Animation speed
  --seed INTEGER          Random seed. Might not affect all things.
  --filename FILE         Filename for image output (should end with .png or
                          .jpg)  [default: art.png]
  --with-alpha            Include alpha channel
  --with-supersample      Apply x2 supersample anti-aliasing
  --with-fxaa             Apply FXAA anti-aliasing
  --debug-print           Debug: Print ancestors and settings to STDOUT
  --debug-out FILE        Debug: Log ancestors and settings to file
  --help-presets          Show available generator presets and exit.
  -h, --help              Show this message and exit.
`;

function formatApplyHelp() {
  return `Usage: noisemaker-js apply [OPTIONS] PRESET_NAME INPUT_FILENAME

  Apply an effect to a .png or .jpg image

Options:
  --seed INTEGER   Random seed. Might not affect all things.
  --filename FILE  Filename for image output (should end with .png or .jpg)
                   [default: mangled.png]
  --no-resize      Don't resize image. May break some presets.
  --with-fxaa      Apply FXAA anti-aliasing
  --time FLOAT     Time value for Z axis (simplex only)
  --speed FLOAT    Animation speed
  --help-presets   Show available effect presets and exit.
  PRESET_NAME may be "random" or any name shown via --help-presets.
  -h, --help       Show this message and exit.
`;
}

function printMainHelp() {
  console.log(MAIN_HELP);
}

function printGenerateHelp() {
  console.log(GENERATE_HELP);
}

function parseGenerateOptions(tokens) {
  const options = {
    filename: 'art.png',
    width: 1024,
    height: 1024,
    seed: null,
    time: 0,
    speed: 0.25,
    withAlpha: false,
    withSupersample: false,
    withFxaa: false,
    debugPrint: false,
    debugOut: null,
    helpPresets: false,
  };

  const flagOptions = new Set(['with-alpha', 'with-supersample', 'with-fxaa', 'debug-print', 'help-presets']);

  for (let i = 0; i < tokens.length; i += 1) {
    const token = tokens[i];
    if (token === '-h' || token === '--help') {
      options.help = true;
      continue;
    }

    if (!token.startsWith('-')) {
      throw new Error(`Unrecognized argument "${token}"`);
    }

    if (token.startsWith('-') && !token.startsWith('--')) {
      throw new Error(`Unknown option "${token}"`);
    }

    let key;
    let value = null;
    const eqIndex = token.indexOf('=');
    if (eqIndex !== -1) {
      key = token.slice(2, eqIndex);
      value = token.slice(eqIndex + 1);
    } else {
      key = token.slice(2);
    }

    if (flagOptions.has(key)) {
      if (value !== null) {
        throw new Error(`Option "--${key}" does not accept a value`);
      }
      if (key === 'with-alpha') {
        options.withAlpha = true;
      } else if (key === 'with-supersample') {
        options.withSupersample = true;
      } else if (key === 'with-fxaa') {
        options.withFxaa = true;
      } else if (key === 'debug-print') {
        options.debugPrint = true;
      } else if (key === 'help-presets') {
        options.helpPresets = true;
      }
      continue;
    }

    if (value === null) {
      const next = tokens[++i];
      if (next === undefined) {
        throw new Error(`Option "--${key}" requires a value`);
      }
      value = next;
    }

    switch (key) {
      case 'filename':
        options.filename = value;
        break;
      case 'width':
        options.width = Number.parseInt(value, 10);
        break;
      case 'height':
        options.height = Number.parseInt(value, 10);
        break;
      case 'seed':
        options.seed = Number.parseInt(value, 10);
        break;
      case 'time':
        options.time = Number.parseFloat(value);
        break;
      case 'speed':
        options.speed = Number.parseFloat(value);
        break;
      case 'debug-out':
        options.debugOut = value;
        break;
      default:
        throw new Error(`Unknown option "--${key}"`);
    }
  }

  if (Number.isNaN(options.width) || options.width <= 0) {
    throw new Error('Width must be a positive integer');
  }
  if (Number.isNaN(options.height) || options.height <= 0) {
    throw new Error('Height must be a positive integer');
  }
  if (options.seed !== null && Number.isNaN(options.seed)) {
    throw new Error('Seed must be a number');
  }
  if (Number.isNaN(options.time)) {
    throw new Error('Time must be a number');
  }
  if (!Number.isFinite(options.speed) || Number.isNaN(options.speed)) {
    throw new Error('Speed must be a finite number');
  }

  return options;
}

function parseApplyOptions(tokens) {
  const options = {
    filename: 'mangled.png',
    seed: null,
    time: 0,
    speed: 0.25,
    noResize: false,
    withFxaa: false,
    helpPresets: false,
  };

  const flagOptions = new Set(['no-resize', 'with-fxaa', 'help-presets']);

  for (let i = 0; i < tokens.length; i += 1) {
    const token = tokens[i];
    if (token === '-h' || token === '--help') {
      options.help = true;
      continue;
    }

    if (!token.startsWith('-')) {
      throw new Error(`Unrecognized argument "${token}"`);
    }

    if (token.startsWith('-') && !token.startsWith('--')) {
      throw new Error(`Unknown option "${token}"`);
    }

    let key;
    let value = null;
    const eqIndex = token.indexOf('=');
    if (eqIndex !== -1) {
      key = token.slice(2, eqIndex);
      value = token.slice(eqIndex + 1);
    } else {
      key = token.slice(2);
    }

    if (flagOptions.has(key)) {
      if (value !== null) {
        throw new Error(`Option "--${key}" does not accept a value`);
      }
      if (key === 'no-resize') {
        options.noResize = true;
      } else if (key === 'with-fxaa') {
        options.withFxaa = true;
      } else if (key === 'help-presets') {
        options.helpPresets = true;
      }
      continue;
    }

    if (value === null) {
      const next = tokens[++i];
      if (next === undefined) {
        throw new Error(`Option "--${key}" requires a value`);
      }
      value = next;
    }

    switch (key) {
      case 'filename':
        options.filename = value;
        break;
      case 'seed':
        options.seed = Number.parseInt(value, 10);
        break;
      case 'time':
        options.time = Number.parseFloat(value);
        break;
      case 'speed':
        options.speed = Number.parseFloat(value);
        break;
      default:
        throw new Error(`Unknown option "--${key}"`);
    }
  }

  if (options.seed !== null && Number.isNaN(options.seed)) {
    throw new Error('Seed must be a number');
  }
  if (Number.isNaN(options.time)) {
    throw new Error('Time must be a number');
  }
  if (!Number.isFinite(options.speed) || Number.isNaN(options.speed)) {
    throw new Error('Speed must be a finite number');
  }

  return options;
}

function clampToByte(value) {
  if (!Number.isFinite(value)) {
    return 0;
  }
  const scaled = Math.round(value * 255);
  return Math.max(0, Math.min(255, scaled));
}

async function tensorToImageData(tensor) {
  const [height, width, channels] = tensor.shape;
  const dataMaybe = tensor.read();
  const raw = dataMaybe && typeof dataMaybe.then === 'function' ? await dataMaybe : dataMaybe;
  const data = raw instanceof Float32Array ? raw : Float32Array.from(raw ?? []);
  const totalPixels = width * height;
  const out = new Uint8ClampedArray(totalPixels * 4);
  for (let i = 0; i < totalPixels; i += 1) {
    const src = i * channels;
    const dst = i * 4;
    const r = data[src] ?? 0;
    const g = channels > 1 ? data[src + 1] : r;
    const b = channels > 2 ? data[src + 2] : r;
    const a = channels > 3 ? data[src + 3] : channels === 2 ? data[src + 1] : 1;
    out[dst] = clampToByte(r);
    out[dst + 1] = clampToByte(g);
    out[dst + 2] = clampToByte(b);
    out[dst + 3] = clampToByte(a);
  }
  return { width, height, data: out };
}

async function writeImage(tensor, filename) {
  const { width, height, data } = await tensorToImageData(tensor);
  const outputPath = path.resolve(process.cwd(), filename);
  const directory = path.dirname(outputPath);
  await mkdir(directory, { recursive: true });

  const extension = path.extname(outputPath).toLowerCase();
  if (extension === '.jpg' || extension === '.jpeg') {
    const encoded = jpeg.encode({ data: Buffer.from(data), width, height }, 95);
    await writeFile(outputPath, encoded.data);
  } else {
    const png = new PNG({ width, height });
    png.data = Buffer.from(data);
    await new Promise((resolve, reject) => {
      const stream = createWriteStream(outputPath);
      stream.on('finish', resolve);
      stream.on('error', reject);
      png.pack().pipe(stream);
    });
  }

  return outputPath;
}

async function loadInputTensor(filename) {
  const resolvedPath = path.resolve(process.cwd(), filename);
  const extension = path.extname(resolvedPath).toLowerCase();
  const buffer = await readFile(resolvedPath);

  let width = 0;
  let height = 0;
  let rawData = null;

  if (extension === '.png') {
    const png = PNG.sync.read(buffer, { checkCRC: true });
    width = png.width;
    height = png.height;
    rawData = png.data;
  } else if (extension === '.jpg' || extension === '.jpeg') {
    const decoded = jpeg.decode(buffer, { useTArray: true });
    width = decoded.width;
    height = decoded.height;
    rawData = decoded.data;
  } else {
    throw new Error(`Unsupported input format for "${filename}". Expected .png or .jpg`);
  }

  if (!width || !height || !rawData) {
    throw new Error(`Unable to load image "${filename}"`);
  }

  const channels = 3;
  const totalPixels = width * height;
  const out = new Float32Array(totalPixels * channels);
  for (let i = 0; i < totalPixels; i += 1) {
    const src = i * 4;
    const dst = i * channels;
    const r = (rawData[src] ?? 0) / 255;
    const g = (rawData[src + 1] ?? 0) / 255;
    const b = (rawData[src + 2] ?? 0) / 255;
    out[dst] = Number.isFinite(r) ? r : 0;
    out[dst + 1] = Number.isFinite(g) ? g : out[dst];
    out[dst + 2] = Number.isFinite(b) ? b : out[dst];
  }

  const tensor = Tensor.fromArray(null, out, [height, width, channels]);
  return { tensor, shape: tensor.shape.slice() };
}

function instantiatePreset(presetName, presets, seed, opts = {}) {
  random();
  random();
  random();
  return new Preset(presetName, presets, undefined, seed, opts);
}

let cachedGeneratorNames = null;
let cachedEffectNames = null;

function getGeneratorPresetNames() {
  if (cachedGeneratorNames) {
    return cachedGeneratorNames;
  }
  const presets = PRESETS();
  const names = [];
  for (const name of Object.keys(presets)) {
    try {
      const preset = instantiatePreset(name, presets, 1);
      if (preset.is_generator()) {
        names.push(name);
      }
    } catch (error) {
      if (error instanceof Error && error.message.includes(`Preset "${name}"`)) {
        throw error;
      }
      continue;
    }
  }
  names.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
  cachedGeneratorNames = names;
  return names;
}

function getEffectPresetNames() {
  if (cachedEffectNames) {
    return cachedEffectNames;
  }
  const presets = PRESETS();
  const names = [];
  for (const name of Object.keys(presets)) {
    try {
      const preset = instantiatePreset(name, presets, 1);
      if (!preset.is_generator() && preset.is_effect()) {
        names.push(name);
      }
    } catch (error) {
      if (error instanceof Error && error.message.includes(`Preset "${name}"`)) {
        throw error;
      }
      continue;
    }
  }
  names.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
  cachedEffectNames = names;
  return names;
}

function printPresetList(header, names) {
  console.log(header);
  for (const name of names) {
    console.log(`  - ${name}`);
  }
}

function splitGenerateArgs(args) {
  let helpRequested = false;
  let presetName = null;
  const optionTokens = [];
  let parsingOptions = true;

  for (let i = 0; i < args.length; i += 1) {
    const arg = args[i];

    if (parsingOptions && (arg === '--help' || arg === '-h')) {
      helpRequested = true;
      continue;
    }

    if (parsingOptions && arg === '--') {
      parsingOptions = false;
      continue;
    }

    if (parsingOptions && arg.startsWith('-') && arg !== '-') {
      optionTokens.push(arg);
      const needsValue =
        arg.startsWith('--') &&
        !arg.includes('=') &&
        !['--with-alpha', '--with-supersample', '--with-fxaa', '--debug-print', '--help-presets', '--help', '-h'].includes(arg);
      if (needsValue) {
        const value = args[i + 1];
        if (value === undefined) {
          throw new Error(`Option "${arg}" requires a value`);
        }
        optionTokens.push(value);
        i += 1;
      }
      continue;
    }

    if (presetName === null) {
      presetName = arg;
      continue;
    }

    if (parsingOptions && arg.startsWith('-') && arg.length > 1) {
      throw new Error(`Unknown option "${arg}"`);
    }

    throw new Error(`Unexpected argument "${arg}"`);
  }

  return { helpRequested, presetName, optionTokens };
}

function splitApplyArgs(args) {
  let helpRequested = false;
  let presetName = null;
  let inputFilename = null;
  const optionTokens = [];
  let parsingOptions = true;

  for (let i = 0; i < args.length; i += 1) {
    const arg = args[i];

    if (parsingOptions && (arg === '--help' || arg === '-h')) {
      helpRequested = true;
      continue;
    }

    if (parsingOptions && arg === '--') {
      parsingOptions = false;
      continue;
    }

    if (parsingOptions && arg.startsWith('-') && arg !== '-') {
      optionTokens.push(arg);
      const needsValue =
        arg.startsWith('--') &&
        !arg.includes('=') &&
        !['--no-resize', '--with-fxaa', '--help-presets', '--help', '-h'].includes(arg);
      if (needsValue) {
        const value = args[i + 1];
        if (value === undefined) {
          throw new Error(`Option "${arg}" requires a value`);
        }
        optionTokens.push(value);
        i += 1;
      }
      continue;
    }

    if (presetName === null) {
      presetName = arg;
      continue;
    }

    if (inputFilename === null) {
      inputFilename = arg;
      continue;
    }

    if (parsingOptions && arg.startsWith('-') && arg.length > 1) {
      throw new Error(`Unknown option "${arg}"`);
    }

    throw new Error(`Unexpected argument "${arg}"`);
  }

  return { helpRequested, presetName, inputFilename, optionTokens };
}

function humanizeName(name) {
  return String(name || '')
    .replace(/_/g, ' ')
    .replace(/-/g, ' ');
}

function effectDisplayName(effect) {
  if (!effect) {
    return 'anonymous';
  }
  if (typeof effect === 'function') {
    if (effect.__effectName) {
      return humanizeName(effect.__effectName);
    }
    if (effect.name) {
      return humanizeName(effect.name);
    }
  }
  if (typeof effect === 'object') {
    if (effect.__effectName) {
      return humanizeName(effect.__effectName);
    }
    if (effect.name) {
      return humanizeName(effect.name);
    }
    if (effect.func && effect.func.name) {
      return humanizeName(effect.func.name);
    }
  }
  return 'anonymous';
}

function formatPresetDebug(preset, seed, options) {
  const firstColumn = ['Layers:'];
  firstColumn.push('  - Lineage (by newest):');
  const layers = Array.isArray(preset.flattened_layers) ? preset.flattened_layers.slice() : [];
  if (!layers.length) {
    firstColumn.push('    - None');
  } else {
    for (const name of layers.slice().reverse()) {
      firstColumn.push(`    - ${name}`);
    }
  }
  firstColumn.push('');
  firstColumn.push('  - Effects (by newest):');

  const finalEffects = Array.isArray(preset.final_effects) ? preset.final_effects : [];
  const postEffects = Array.isArray(preset.post_effects) ? preset.post_effects : [];
  const octaveEffects = Array.isArray(preset.octave_effects) ? preset.octave_effects : [];

  if (!finalEffects.length && !postEffects.length && !octaveEffects.length) {
    firstColumn.push('    - None');
    firstColumn.push('');
  }

  if (finalEffects.length) {
    firstColumn.push('    - Final Pass:');
    for (const effect of finalEffects.slice().reverse()) {
      firstColumn.push(`      - ${effectDisplayName(effect)}`);
    }
    firstColumn.push('');
  }

  if (postEffects.length) {
    firstColumn.push('    - Post Pass:');
    for (const effect of postEffects.slice().reverse()) {
      firstColumn.push(`      - ${effectDisplayName(effect)}`);
    }
    firstColumn.push('');
  }

  if (octaveEffects.length) {
    firstColumn.push('    - Per-Octave Pass:');
    for (const effect of octaveEffects.slice().reverse()) {
      firstColumn.push(`      - ${effectDisplayName(effect)}`);
    }
    firstColumn.push('');
  }

  firstColumn.push('Canvas:');
  firstColumn.push(`  - seed: ${seed}`);
  firstColumn.push(`  - with alpha: ${options.withAlpha ? 'True' : 'False'}`);
  firstColumn.push(`  - with supersample: ${options.withSupersample ? 'True' : 'False'}`);
  firstColumn.push(`  - with fxaa: ${options.withFxaa ? 'True' : 'False'}`);
  firstColumn.push('');

  const secondColumn = ['Settings:'];
  const settings = Object.entries(preset.settings || {})
    .sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));

  for (const [key, value] of settings) {
    let displayValue;
    if (typeof value === 'number') {
      const rounded = Math.round(value * 1000) / 1000;
      displayValue = Number.isFinite(rounded) ? rounded : value;
    } else if (Array.isArray(value)) {
      displayValue = `[${value.join(', ')}]`;
    } else if (value && typeof value === 'object' && 'name' in value) {
      displayValue = value.name;
    } else {
      displayValue = value;
    }
    secondColumn.push(`  - ${humanizeName(key)}: ${displayValue}`);
  }
  secondColumn.push('');

  const lines = [];
  const maxLength = Math.max(firstColumn.length, secondColumn.length);
  for (let i = 0; i < maxLength; i += 1) {
    const left = firstColumn[i] || '';
    const right = secondColumn[i] || '';
    const paddedLeft = left.padEnd(50, ' ');
    lines.push(`${paddedLeft} ${right}`);
  }
  return lines;
}

async function maybeWriteDebug(options, preset, seed) {
  if (!options.debugPrint && !options.debugOut) {
    return;
  }
  const lines = formatPresetDebug(preset, seed, options);
  if (options.debugPrint) {
    for (const line of lines) {
      console.log(line);
    }
  }
  if (options.debugOut) {
    await writeFile(options.debugOut, `${lines.join('\n')}\n`);
  }
}

async function handleGenerate(args) {
  const { helpRequested, presetName, optionTokens } = splitGenerateArgs(args);
  const options = parseGenerateOptions(optionTokens);

  if (helpRequested || options.help) {
    printGenerateHelp();
    return 0;
  }

  if (options.helpPresets) {
    const generatorNames = getGeneratorPresetNames();
    printPresetList('Available generator presets:', ['random', ...generatorNames]);
    return 0;
  }

  if (!presetName) {
    throw new Error("Error: Missing argument 'PRESET_NAME'.");
  }

  const presets = PRESETS();
  let resolvedName = presetName;

  if (presetName === 'random') {
    const generatorNames = getGeneratorPresetNames();
    if (!generatorNames.length) {
      throw new Error('No generator presets are available.');
    }
    const index = Math.floor(Math.random() * generatorNames.length);
    resolvedName = generatorNames[index];
  } else if (!Object.prototype.hasOwnProperty.call(presets, resolvedName)) {
    throw new Error(`Unknown preset: ${resolvedName}`);
  }

  let seed = options.seed;
  if (!Number.isFinite(seed) || seed === null || seed === 0) {
    seed = Math.floor(Math.random() * MAX_SEED_VALUE) + 1;
  }

  setUtilSeed(seed);
  setValueSeed(seed);

  const debugMode = Boolean(options.debugPrint || options.debugOut);
  const preset = instantiatePreset(resolvedName, presets, seed, { debug: debugMode });
  const ctx = new Context(null, debugMode);

  await maybeWriteDebug(options, preset, seed);

  const tensor = await preset.render(seed, {
    ctx,
    width: options.width,
    height: options.height,
    time: options.time,
    speed: options.speed,
    withAlpha: options.withAlpha,
    withSupersample: options.withSupersample,
    withFxaa: options.withFxaa,
    debug: debugMode,
  });

  await writeImage(tensor, options.filename);
  console.log(preset.name);
  return 0;
}

async function handleApply(args) {
  const { helpRequested, presetName, inputFilename, optionTokens } = splitApplyArgs(args);
  const options = parseApplyOptions(optionTokens);

  if (helpRequested || options.help) {
    const helpMessage = formatApplyHelp();
    console.log(helpMessage);
    return 0;
  }

  if (options.helpPresets) {
    const effectNames = getEffectPresetNames();
    printPresetList('Available effect presets:', ['random', ...effectNames]);
    return 0;
  }

  if (!presetName) {
    throw new Error("Error: Missing argument 'PRESET_NAME'.");
  }

  if (!inputFilename) {
    throw new Error("Error: Missing argument 'INPUT_FILENAME'.");
  }

  const effectNames = getEffectPresetNames();
  if (!effectNames.length) {
    throw new Error('No effect presets are available.');
  }

  let resolvedName = presetName;
  if (presetName === 'random') {
    const index = Math.floor(Math.random() * effectNames.length);
    resolvedName = effectNames[index];
  } else if (!effectNames.includes(resolvedName)) {
    const available = effectNames.join(', ');
    throw new Error(`Effect preset "${resolvedName}" not found. Available presets: ${available}`);
  }

  let seed = options.seed;
  if (!Number.isFinite(seed) || seed === null || seed === 0) {
    seed = Math.floor(Math.random() * MAX_SEED_VALUE) + 1;
  }

  setUtilSeed(seed);
  setValueSeed(seed);

  const presets = PRESETS();
  const preset = instantiatePreset(resolvedName, presets, seed);

  const { tensor: inputTensor, shape: inputShape } = await loadInputTensor(inputFilename);
  let workingTensor = inputTensor;
  let workingShape = inputShape.slice();

  if (!options.noResize) {
    workingTensor = await squareCropAndResize(workingTensor, workingShape, 1024);
    workingShape = workingTensor.shape.slice();
  }

  const ctx = new Context(null, false);
  const result = await preset.render(seed, {
    ctx,
    tensor: workingTensor,
    width: workingShape[1],
    height: workingShape[0],
    withAlpha: false,
    withFxaa: options.withFxaa,
    time: options.time,
    speed: options.speed,
  });

  console.log(preset.name);
  await writeImage(result, options.filename);
  return 0;
}

async function main(argv) {
  if (!argv.length) {
    printMainHelp();
    return 0;
  }

  if (argv[0] === '--help' || argv[0] === '-h') {
    printMainHelp();
    return 0;
  }

  if (argv[0] === '--version') {
    console.log(`noisemaker-js, version ${VERSION}`);
    return 0;
  }

  const [command, ...rest] = argv;
  if (command === 'generate') {
    return handleGenerate(rest.length ? rest : []);
  }
  if (command === 'apply') {
    return handleApply(rest.length ? rest : []);
  }

  throw new Error(`Unknown command "${command}"`);
}

main(process.argv.slice(2))
  .then((code) => {
    if (typeof code === 'number') {
      process.exitCode = code;
    }
  })
  .catch((error) => {
    console.error(error instanceof Error ? error.message : String(error));
    process.exit(1);
  });
